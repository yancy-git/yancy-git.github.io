[{"title":"关于前端常用跨域方式","path":"/2023/03/14/关于前端跨域/","content":"同源策略同源是指协议、域名、端口三种相同，任意一种对应不上，我们就称之为跨域 前端跨域方案jsonpJSONP实现跨域请求的原理就是动态创建script标签，利用“src”不受同源策略约束的性质来实现跨域获取数据。 特性：JSONP方案属于客户端直接请求，不存在二次请求的问题；但是，不足是script标签只能发起get请求。简单例子 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JSONP 实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; function callbackFunction(data)&#123; console.log(&quot;i got it&quot;)； console.log(data); &#125;&lt;/script&gt;&lt;script&gt; window.onload=function()&#123; var script=document.createElement(&quot;script&quot;); script.src=&quot;https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction&quot;; document.head.append(script)； &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用代理在vue项目中，我们可以通过配置代理来解决跨域问题 vue.config.js12345678910111213devServer: &#123; host: &#x27;localhost&#x27;, port: &#x27;3000&#x27;, proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;xxxxxxxx&#x27;, // 真实地址 changeOrigin: true, pathRewrite: &#123; &#x27;/api&#x27;: &#x27;&#x27; &#125; &#125; &#125;&#125; CORS严格来说这个不太属于前端范畴，找你的后端同事设置Access-Control-Allow-Origin等,包括携带token也需要后端放开Authorization 后记话说现在jsonp其实不太常用了，比较早的方式，基本都用另外两种昂~","tags":["跨域"],"categories":["前端学习"]},{"title":"前端优化手段","path":"/2023/02/13/前端优化手段/","content":"前言前端进阶之路，做好优化必不可少，这里整理一下常用的优化手段以及理论上的优化手段但是不太常用的。根据参考文章，查了一下比较通用的整理出来 常用、可行的优化方式减少请求数量 图片处理 精灵图（比较老旧的方式了） base64（别大量使用，会影响打包体积） 字体图标（最通用的方案） 减少重定向 a标签设置空href会导致重定向到当前页面（主动触发，否则不会影响） 浏览器缓存 cach-control或expires强缓存（状态码200，会标注disk&#x2F;memory cache） last-modified或etag协商缓存，资源更新从服务器(200)拿否则使用本地缓存(304) 优化网络连接 dns预获取 使用内容分发网络cdn 减小资源大小 压缩 html压缩 css压缩 js压缩与混乱 限制图片大小，或者使用css.filter设置例如contrast对比度舍弃一些色彩信息 webp图片格式 gzip压缩一般对纯文本内容可压缩到原大小的40% 优化资源加载 资源加载位置 CSS文件放在head中，先外链，后本页 JS文件放在body底部，先外链，后本页 处理页面、处理页面布局的JS文件放在head中，如babel-polyfill.js文件、flexible.js文件 body中间尽量不写style标签和script标签 资源加载时机 defer&#x2F;async 异步script标签 模块按需加载 ECMAScript 提案 的 import() 语法 webpack 特定的 require.ensure 使用资源预加载preload和资源预读取prefetch preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度 prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度 资源懒加载与资源预加载 减少重绘回流 样式设置 避免使用层级较深的选择器 避免使用CSS表达式 css transform可以触发GPU硬件加速 渲染层 将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围 DOM优化 如果要批量操作dom，使用文档片段，只批量回流一次 批量操作css，提前写好class进行更换是比较好的方案 可以先display：none删除元素，操作后再显示，和使用文档片段的目的一致，都是一次性回流重绘 列表不要给子元素循环绑定事件，而是事件委托 防抖和节流 及时清理环境 性能更好的API 使用IntersectionObserver来实现图片可视区域的懒加载 webpack优化 打包公共代码 使用CommonsChunkPlugin插件，将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件 webpack 4 将移除 CommonsChunkPlugin, 取而代之的是两个新的配置项 optimization.splitChunks 和 optimization.runtimeChunk 通过设置 optimization.splitChunks.chunks: “all” 来启动默认的代码分割配置项 动态导入和按需加载 同上，ECMAScript 提案 的 import() 语法和 webpack 特定的 require.ensure tree shaking剔除无用代码 JS的tree shaking主要通过uglifyjs插件来完成 CSS的tree shaking主要通过purify CSS来实现的 Vue keep-alive组件保活 v-for指定唯一不变key","tags":["优化"],"categories":["前端学习"]},{"title":"关于vue3状态管理，还要什么自行车啊","path":"/2022/08/21/关于vue3状态管理，-还要什么自行车啊/","content":"最近写vue3项目，需要做状态管理及其持久化，vuex用的太多了，不免觉得它过于臃肿，于是乎看了一下vue3的pinia方案，感觉用不上啊。不如直接自己写个简易版的，刚好够自己项目用的才是最合适的 自己写的这个可能扩展性不够,但是我是小项目,够用就行 在src下新建store1234567891011121314151617181920// store/user.jsimport &#123; ref &#125; from &quot;vue&quot;;const store = ref(&#123;\tstate: &#123;&#125;&#125;)function getStore() &#123;\treturn store.value&#125;function setStore(val) &#123; store = ref(&#123; state: val &#125;)&#125;export const useUserStore = () =&gt; (&#123; store, getStore, setStore,&#125;); 登录时存储用户信息123456// 代码仅作示例const &#123; setStore, getStore &#125; = useUserStore();login(data).then(user =&gt; &#123;\tsetStore(user)&#125;) 页面刷新时使用sessionStorage做持久化1234567891011// app.vue文件onMounted(() =&gt; &#123; if(sessionStorage.getItem(&#x27;store&#x27;)) &#123; setStore(JSON.parse(sessionStorage.getItem(&#x27;store&#x27;))) &#125; // 这里不要用alert来测试beforeunload绑定, 触发不了的,实测. 可以打开f12看sessionStorage的变化就可以 window.addEventListener(&#x27;beforeunload&#x27;, () =&gt; &#123; sessionStorage.setItem(&#x27;store&#x27;, JSON.stringify(getStore())) &#125;)&#125;) 最后以上代码仅作示例,没有写具体的其他操作, 是测过了,这一套逻辑可用, 有了响应式对象,要什么自行车啊-.- 参考文章","tags":["Vue"],"categories":["前端学习"]},{"title":"windows上安装使用redis，支持express本地开发","path":"/2022/07/21/windows上安装使用redis，支持express本地开发/","content":"下载redis后默认启动 或者在redis安装目录下打开cmd，运行redis-server.exe redis.windows.conf 也可以在右键我的电脑-在服务中将redis启动并设置为自启动 打开另一个cmd窗口输入redis-cli -h localhost -p 6379默认是没有密码的 在这里面可以输入命令查看redis的一些状态和存储的内容，也可以下载redis可视化客户端，略 项目中安装redsnpm i redis --save 配置创建redis 文件夹 新建redisConfig.js 文件， 1 回到 test.js 文件，写入如下代码测试 12const redis = require(&#x27;../redis/redisConfig&#x27;);redis.setValue(&#x27;testKey&#x27;, &#x27;testValue&#x27;); 进入命令行窗口测试 123456// 进入redisredis0-cli -h localhost -p 6379// 如下 输入get testkeylocalhost:6379&gt; get testkey&quot;testValue&quot;","tags":["Redis"],"categories":["环境搭建"]},{"title":"webpack部署阶段gzip优化","path":"/2022/06/14/webpack优化之Gzip-vue/","content":"Gzip压缩原理Gzip 压缩背后的原理，是在一个文本文件中找出一些重复出现的字符串、临时替换它们，从而使整个文件变小。 应用场景打包过后体积过大，导致首屏加载时间长，一直白屏，体验很不好 webpack 的 Gzip 和服务端的Gzip我们开发完成，进行部署打包的时候，配置一下webpack: vue.config.js123456789101112131415161718192021222324const IS_PROD = [&#x27;prod&#x27;, &#x27;production&#x27;].includes(process.env.NODE_ENV)//gzip压缩const productionGzipExtensions = /\\.(js|css|json|html)(\\?.*)?$/i; //匹配格式const CompressionWebpackPlugin = require(&quot;compression-webpack-plugin&quot;); module.exports = &#123; configureWebpack: config =&gt; &#123; let plugins = [] if (IS_PROD) &#123; // prod添加gzip压缩 plugins.push( new CompressionWebpackPlugin(&#123; filename: &quot;[path].gz[query]&quot;, algorithm: &quot;gzip&quot;, test: productionGzipExtensions, threshold: 10240,// 大于10kb的才被压缩 minRatio: 0.8//压缩比例 &#125;) ); &#125; config.plugins = [...config.plugins, ...plugins]; &#125;,&#125; 不要以为到这里就完事了如果需要线上的项目引用压缩的后的资源，我们需要配置nginx的http模块： 12345gzip_static on;gzip_http_version 1.1;gzip_proxied expired no-cache no-store private auth;gzip_disable &quot;MSIE [1-6]\\.&quot;;gzip_vary on; 关于服务端的gzip这里说一下前端验证服务端是否支持Gzip方式，可以在请求中查看响应头是否存在content-encoding: gzip再多一嘴，如果是node之类的框架的话需要引入compression中间件才能支持gzip 1234// 服务端开启Gzip支持var compression = require(&#x27;compression&#x27;);//尽量在其他中间件前使用compressionapp.use(compression()); 后记除非特别大的项目，一般不会同时用到这俩个小说说，推荐compression-webpack-plugin版本5.0.1,没看到可不怪我，高版本有坑","tags":["优化","Webpack"],"categories":["前端学习"]},{"title":"vue3项目中axios封装以及其post请求头的区别","path":"/2022/05/21/vue3项目中axios封装以及其post请求头的区别/","content":"项目中安装依赖123npm install axios# 或者yarn add axios 在src目录下新建axios文件夹并在其中新建index.js文件 有些人喜欢把axios绑定到Vue的原型对象上，在页面中调用的时候还需要自己配置具体参数之类的，我不喜欢这种方式，我喜欢直接定义配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// /src/axios/index.jsconst service = axios.create(&#123;\t//vue2 通过process访问自定义的.env环境文件来进进行配置，常量需要VUE_APP开头\t//baseURL: process.env.VUE_APP_BASE_URL, // vue3 通过在import.meta.env访问，且.env文件中的常量必须以vite开头\tbaseURL: import.meta.env.VITE_BASE_URL, //这里vue2和3是一样的\ttimeout: 8000&#125;)// 自定义请求头service.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;;// 请求拦截service.interceptors.request.use((config) =&gt; &#123;\t// TODO\t// 例如需要加上token的请求在这里设置请求头\tconst headers = config.headers;\tif (!headers.Authorization) &#123; headers.Authorization = &#x27;Bear Test&#x27;\t&#125;\treturn config;&#125;);// 响应拦截service.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 // 例如获取token之后可以在这里进行获取并存入localstorage // 例如拦截到404直接跳转到自定义404页面 return response;&#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error);&#125;);/** * 封装get方法 * @param url * @param data * @returns &#123;Promise&#125; */export function get(url, params = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; service.get(url, &#123; params: params &#125;) .then(response =&gt; &#123; // 这里相当于进行了数据统一剥离，取用的时候少一层，方便多了， post同理 resolve(response.data); &#125;) .catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;/** * 封装post请求 * @param url * @param data * @returns &#123;Promise&#125; */export function post(url, data = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; service.post(url, data) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err) &#125;) &#125;)&#125; 参考文章 post请求头配置问题12345678// 上传图片 Content-type: multipart/form-data// 我一般喜欢用的默认格式Content-type: application/x-www-form-urlencoded// json格式Content-type: application/json 简单说下application&#x2F;x-www-form-urlencoded和application&#x2F;json： 相同点： 它们俩都能进行表单提交和对象形式的数据的请求 不同点： json模式下默认会发两次请求，比urlencoded这个模式多一种，多的是options请求，我们称之为“预检请求”，options请求主要用于获知服务端支持的HTTP请求方法。跨域资源共享(CORS)标准新增了一组 HTTP 首部字段，配合预检请求可获知服务器允许哪些源站通过浏览器有权限访问哪些资源。后端同时一般遇到options类型的请求会直接返回 urlencoded请求头时，虽然一般和json格式下一下给定一个对象，但是在发送请求之前我们需要处理一下该请求的参数，urlencoded模式下，data参数需要序列化，序列化的结果就是类似get请求的name&#x3D;1&amp;age&#x3D;1，但是他不会明文显示在url拼接上，我们一把有几种方式处理 最常用的 qs.stringify(data) 使用**URLSearchParams对象并遍历data的key，然后使用URLSearchParams.set(key, value)**的方式序列化 使用encodeURIComponent，具体可以查阅MDN 用户设置了自定义请求头的也会触发预检请求，例如config.header[‘Authorization’] 携带token信息","tags":["Vue","Axios"],"categories":["前端学习"]},{"title":"VueRouter小结","path":"/2022/04/21/VueRouter小结/","content":"动态路由&#123;path: &#39;&#39;/users/:id, component: User&#125; 当路由匹配时，它的params将以this.$route.params形式暴露出来，可以使用以下方式在组件中访问&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt; 响应路由参数变化监听路由1234567891011const User = &#123;template: &#x27;...&#x27;,created() &#123; this.$watch( () =&gt; this.$route.params, (toParams, previousParams) =&gt; &#123; // 对路由变化做出响应... &#125; )&#125;,&#125; 使用导航守卫12345678const User = &#123; template: &#x27;...&#x27;, async beforeRouteUpdate(to, from) &#123; // 对路由变化做出响应... this.userData = await fetchUser(to.params.id) &#125;,&#125; 路由匹配语法定义正则 针对情景：路由静态部分相同，或者没有静态部分，例如{path: &#x2F;:orderId}和{&#x2F;:productName} 123456const routes = [ // /:orderId -&gt; 仅匹配数字 &#123; path: &#x27;/:orderId(\\\\d+)&#x27; &#125;, // /:productName -&gt; 匹配其他任何内容 &#123; path: &#x27;/:productName&#x27; &#125;,] 可重复参数123456const routes = [ // /:chapters -&gt; 匹配 /one, /one/two, /one/two/three, 等 &#123; path: &#x27;/:chapters+&#x27; &#125;, // /:chapters -&gt; 匹配 /, /one, /one/two, /one/two/three, 等 &#123; path: &#x27;/:chapters*&#x27; &#125;,] Sensitive 与 strict 路由配置 动态匹配默认忽略大小写、末尾斜杠 12345678910111213const router = createRouter(&#123; history: createWebHistory(), routes: [ // 将匹配 /users/posva 而非： // - /users/posva/ 当 strict: true // - /Users/posva 当 sensitive: true &#123; path: &#x27;/users/:id&#x27;, sensitive: true &#125;, // 将匹配 /users, /Users, 以及 /users/42 而非 /users/ 或 /users/42/ &#123; path: &#x27;/users/:id?&#x27; &#125;, ] strict: true, // applies to all routes&#125;) 编程式导航 router.push(), push可以是字符串或者对象,注意点，path和params不能一起用,query参数显示在url上 路由props &lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;的代替写法 123456const User = &#123; // 请确保添加一个与路由参数完全相同的 prop 名 props: [&#x27;id&#x27;], template: &#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;&#125;const routes = [&#123; path: &#x27;/user/:id&#x27;, component: User, props: true &#125;] 除了上面的显示声明props路由动态key，还可以在路由数组中配置props: true值得注意的是，如果有命名视图的路由，定义props时必须覆盖到每个视图 1234567const routes = [ &#123; path: &#x27;/user/:id&#x27;, components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125;] 关于路由传参query类似 get, 跳转之后页面 url后面会拼接参数,例如id&#x3D;1, 非重要性的可以这样传刷新页面后参数id还在 params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失","tags":["VueRouter"],"categories":["前端学习"]},{"title":"nodejs-express项目的debug方式","path":"/2022/03/27/nodejs-express项目的debug方式/","content":"nodejs或者express项目中，断点调试时很重要的，能帮我们快速定位问题。网上的答案也是参差不齐，摸索了很久终于能正常调试了 在package.json中添加脚本命令123&quot;scripts&quot;: &#123; &quot;debug&quot;: &quot;node --inspect-brk ./bin/www&quot;&#125;, 上面的命令启动后默认的端口是9229，口通过在-brk&#x3D;5555的方式指定端口 以debug模式启动1npm run debug //这里的debug对应我们上面的命令key 浏览器访问chrome:&#x2F;&#x2F;inspect&#x2F;#devices其他的都不用管，找到remote target，有时候下面会显示蓝色字体inspect，上面就是.&#x2F;bin&#x2F;www ，就是这个地方，点inspect会弹出一个窗口，这个就是我们后面用来调试的窗口了，现在且回到vscode终端（或是你运行npm run debug的窗口，能看到debugger attached） 断点的方式 在express项目代码中直接写明debugger 在调试窗口导入源文件，使用鼠标在行号处添加断点","tags":["NodeJs"],"categories":["后端开发"]},{"title":"vue+express实现token验证","path":"/2022/03/17/vue-express实现token验证/","content":"Vue部分 保存token前端在登录后将token保存到localStorage, 例如 12// value是后端返回的tokenlocalStorage.setItem(&#x27;token&#x27;, value) axios请求拦截携带token12345678910axios.interceptors.request.use(function(config) &#123;\t//省略.... // tokenUtils自己定义，从localStorage中get就行\t// 这里增加 Bearer 前缀必须要，因为使用的工具包把它当作一个认证手段，简单了解了一下，它是根据这个前缀来决定解析token的算法，没有这个前缀直接报401\tif(tokenUtils.getToken) &#123; config.headers[&#x27;Authorization&#x27;] = `Bearer $&#123;tokenUtils.getToken()&#125;` &#125; return config&#125;) express部分安装依赖1234567// 我这里node版本是16.19.1,前端一样的,我用的yarn 也可以使用npm// 这个是用来生成token的yarn add jsonwebtoken -S//这个是用来解析tokenyarn add express-jwt -S 封装token工具包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var jwt = require(&#x27;jsonwebtoken&#x27;);var jwtScrect = &#x27;123&#x27;; //签名/** * 这里两个参数，一般用一个id就够了，自定义，影响不大 * @param &#123;*&#125; user_name * @param &#123;*&#125; user_id * @returns */var setToken = function (user_name, user_id) &#123; return new Promise((resolve, reject) =&gt; &#123; //expiresln 设置token过期的时间 //&#123; user_name: user_name, user_id: user_id &#125; 传入需要解析的值（ 一般为用户名，用户id 等） const token = jwt.sign(&#123; name: user_name, id: user_id &#125;, jwtScrect, &#123; expiresIn: 3600 * 24 * 3 &#125;); resolve(token) &#125;)&#125;/** * 新版本已经用不到这个了,至少我这里是直接解析了。。。这个是自定义的解析函数，不传也没关系，后面会说到 *不过这里有个token.split(&#x27; &#x27;)[1] 以前的版本就是这样的，也变相说明了Bearer就算没有作用，前面至少也要加个前缀，要不然这里会报错，想来应该是大家都习惯这么用了，新版本高度封装之后默认保留了这个习惯，当然在源码中也能看到自定义的gettoken方法 *///各个接口需要验证token的方法// var getToken = function (req) &#123;// debugger// let token = req.header[&#x27;authorization&#x27;]// return new Promise((resolve, reject) =&gt; &#123;// if (!token) &#123;// reject(&#123;// error: &#x27;no token&#x27;// &#125;)// &#125;// else &#123;// //第二种 改版后的// var info = jwt.verify(token.split(&#x27; &#x27;)[1], jwtScrect);// resolve(info); //解析返回的值（sign 传入的值）// &#125;// &#125;)// &#125;// 这里jwtScrect是我们自定义 约定好的签名，我暴露出去时为了方便在拦截的时候统一使用，也有不暴露出去的，直接在解析的时候写死，跟上面定义的jwtScrect一样就行module.exports = &#123; setToken, jwtScrect&#125; 生成token1234567var tokenUtils = require(&#x27;../utils/token&#x27;) //这就是上面那个文件，路径自己根据实际情况改// 在确认用户登录成功的逻辑中加上代码:tokenUtils.setToken(user.username, user.id).then(token =&gt; &#123;\t//这是伪代码， 意思就是响应中加入token就ok，具体实现不要照抄 res.setToken(token)&#125;) 关于预检请求的一点知识由于我们在前端部分需要自定义请求头中的Authorization字段传递token，所以无论我们的请求方式是哪种，都会有一个预检请求（options请求），所以我们需要在express中告诉前端允许添加自定义请求头 下面这一段代码可以解决跨域问题，并定义服务器支持的content-type以及支持自定义authorization，并告诉你支持的http请求类型，并且遇到预检请求的时候直接返回200 123456789101112app.all(&quot;*&quot;, function(req, res, next)&#123; //设置允许跨域的域名，*代表允许任意域名跨域 res.header(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); //允许的header类型 res.header(&quot;Access-Control-Allow-Headers&quot;,&quot;content-type, authorization&quot;); //跨域允许的请求方式 res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;POST,GET&quot;); if (req.method.toLowerCase() == &#x27;options&#x27;) res.send(200); //让options尝试请求快速结束 else next();&#125;); 验证token123456789const &#123; expressjwt &#125; = require(&#x27;express-jwt&#x27;) //新版本这里就是这样需要解构，不然报错const &#123; jwtScrect &#125; = require(&#x27;./utils/token&#x27;)app.use(expressjwt(&#123; secret: jwtScrect, // 签名的密钥 或 PublicKey,就是我上面暴露的那个签名 algorithms: [&#x27;HS256&#x27;] //我上面说的Bearer前缀在验证的时候区别解析的算法可能就是这里，也有的人用其 //它前缀的，这里不多说&#125;).unless(&#123; path: [&#x27;/user/login&#x27;] // 指定路径不经过 Token 解析&#125;)) 通过验证之后的数据取用例如 123router.post(&#x27;/user/xxx&#x27;, (req, res, next) =&gt; &#123;\t//这里req.auth就能拿到token解析成功的数据，这个数据包括你生成token时给定的所有信息&#125;)","tags":["Vue","Axios","Express"],"categories":["前端学习"]},{"title":"keep-alive组件源码解读","path":"/2022/02/27/keep-alive组件源码解读/","content":"作用keep-alive作为一种vue的内置组件，主要作用是缓存组件状态。当需要组件的切换时，不用重新渲染组件，避免多次渲染，就可以使用keep-alive包裹组件。 props include 字符串或者正则表达式，只有名称匹配的组件会被缓存 exclude 字符串或者正则表达式，任何名臣匹配的组件都不会被缓存 max 数字，最多可以缓多少组件实例 用法keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和transition相似，keep-alive是一个抽象组件：他自身不会渲染一个dom元素，也不会出现在组件的父组件链中。 当组件在keep-alive内被切换，它的activated和deactivated这两个生命周期钩子函数将会被对应执行。 主要用于保留组件状态或者避免重新渲染。 1234567891011121314151617&lt;!-- 基本 --&gt; &lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 多个条件判断的子组件 --&gt;&lt;keep-alive&gt; &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt; &lt;/keep-alive&gt;&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt; &lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;/transition&gt; 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374export default &#123; name: &#x27;keep-alive&#x27;, abstract: true, props: &#123; include: patternTypes, exclude: patternTypes, max: [String, Number] &#125;, created () &#123; this.cache = Object.create(null) // 创建缓存列表 this.keys = [] // 创建缓存组件的key列表 &#125;, destroyed () &#123; for (const key in this.cache) &#123;// keep-alive销毁时,循环清空所有的缓存和key pruneCacheEntry(this.cache, key, this.keys) &#125; &#125;, mounted () &#123;// 会监控include 和 include属性 进行组件的缓存处理 this.$watch(&#x27;include&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; matches(val, name)) &#125;) this.$watch(&#x27;exclude&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; !matches(val, name)) &#125;) &#125;, render () &#123; const slot = this.$slots.default // 会默认拿插槽 const vnode: VNode = getFirstComponentChild(slot) // 只缓存第一个组件 const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions if (componentOptions) &#123; // check pattern const name: ?string = getComponentName(componentOptions) // 取出组件的名字 const &#123; include, exclude &#125; = this if ( // 判断是否缓存 // not included (include &amp;&amp; (!name || !matches(include, name))) || // excluded (exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) ) &#123; return vnode &#125; const &#123; cache, keys &#125; = this const key: ?string = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;) : vnode.key // 如果组件没key 就自己通过 组件的标签和key和cid 拼接一个key if (cache[key]) &#123; // 如果缓存中有key vnode.componentInstance = cache[key].componentInstance // 直接拿到组件实例 // make current key freshest remove(keys, key) // 删除当前的key // LRU 最近最久未使用法 keys.push(key) // 并将key放到缓存的最后面 &#125; else &#123; cache[key] = vnode // 缓存vnode keys.push(key) // 将key 存入 // prune oldest entry if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; // 缓存的太多超过了max就需要删除掉 pruneCacheEntry(cache, keys[0], keys, this._vnode) // 要删除第0个 但是现在渲染的就是第0个 &#125; &#125; vnode.data.keepAlive = true // 并且标准keep-alive下的组件是一个缓存组件 &#125; return vnode || (slot &amp;&amp; slot[0]) // 返回当前的虚拟节点 &#125; 原理keep-alive是一个组件，这个组件中有三个属性，分别是include、exclude、max，在created中创建缓存列表和缓存组件的key列表，销毁的时候会做一个循环销毁清空所有的缓存和key。当mounted时会监控exclude和include属性，进行组件的缓存处理。如果发生变化会动态的添加和删除缓存，渲染的时候会去拿默认插槽，只缓存第一个组件，根据组件的名字判断是否在缓存中，如果在就缓存，不在就return掉。缓存的时候，如果组件没有key，就自己通过组件的标签tag和cid拼接一个key。","tags":["Vue","源码学习"],"categories":["前端学习"]},{"title":"JavaScript中的代理与反射","path":"/2021/04/21/JavaScript中的代理与反射/","content":"本文为阅读JavaScript高级程序第4版时所写 代理基础 代理是目标对象的抽象，它可以用作目标对象的替身，但又是完全独立于目标。 创建空代理1234567891011121314151617181920212223242526const target = &#123;\tid: &#x27;targetId&#x27;&#125;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);// 创建代理对象时给定一个空的字面量handler，不定义行为// 访问属性console.log(target.id, proxy.id); //targetId targetId// 操作目标对象后再进行访问target.id = &#x27;foo&#x27;;console.log(target.id, proxy.id); //foo foo// 操作代理后进行访问proxy.id = &#x27;bar&#x27;;console.log(target.id, proxy.id); //bar bar// hasOwnProperty()方法console.log(target.hasOwnProperty(&#x27;id&#x27;), proxy.hasOwnProperty(&#x27;id&#x27;)); // true true// Proxy.prototype为undefined,因此不能使用instanceof操作符console.log(target instanceof Proxy, proxy instanceof Proxy) // 同一个报错 Function has non-object prototype &#x27;undefined&#x27; ...// 目标对象和代理不相等console.log(target == proxy, target === proxy) // false false 定义捕获器12345678910111213141516171819const target = &#123;\tfoo: &#x27;bar&#x27;&#125;;const handler = &#123; // js中访问属性都会触发get()操作 get() &#123; return &#x27;handler override&#x27;; &#125;&#125;;const proxy = new Proxy(target, handler);console.log(target.foo); // barconsole.log(proxy.foo); // handler overrideconsole.log(target[&#x27;foo&#x27;]); // barconsole.log(proxy[&#x27;foo&#x27;]); // handler overrideconsole.log(Object.create(target)[&#x27;foo&#x27;]); // barconsole.log(Object.create(proxy)[&#x27;foo&#x27;]); // handler override 捕获器参数和反射 API这里拿get()捕获器举例，它接受三个参数：目标对象、查询属性、代理对象， 有了这些参数，我们可以重建原始行为（返回目标对象的对应属性值），也可以对访问进行限制 123456789101112const target = &#123;\tfoo: &#x27;bar&#x27;&#125;;const handler = &#123;\tget(trapTarget, property, receiver) &#123; console.log(trapTarget === target); console.log(property); console.log(receiver === proxy); &#125;&#125;const proxy = new Proxy(target, handler);proxy.foo; // true foo true 通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建 1234567891011121314151617181920const target = &#123;\tfoo: &#x27;bar&#x27;&#125;;const handler = &#123; get() &#123; return Reflect.get(...arguments); &#125;&#125;;const proxy = new Proxy(target, handler);console.log(proxy.foo); // barconsole.log(target.foo); // bar// 另一种更简单的写法，仅作展示，这里不拓展const handler = &#123;\tget: Reflect.get&#125;;const proxy = new Proxy(target, handler);console.log(proxy.foo); // barconsole.log(target.foo); // bar 捕获器不变式 捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。 123456789101112131415161718// 比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError ：const target = &#123;&#125;;// 通过Object.defineProperty()将target的foo属性改为不可配置、不可写Object.defineProperty(target, &#x27;foo&#x27;, &#123; configurable: false, writable: false, value: &#x27;bar&#x27;&#125;);const handler = &#123; get() &#123; return &#x27;qux&#x27;; &#125;&#125;;const proxy = new Proxy(target, handler);console.log(proxy.foo); // TypeError 可撤销代理 Proxy 也暴露了 revocable() 方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（ revoke() ）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError 。 1234567891011121314const target = &#123;\tfoo: &#x27;bar&#x27;&#125;;const handler = &#123; get() &#123; return &#x27;intercepted&#x27;; &#125;&#125;;// 撤销函数(revoke)和代理对象(proxy)是在实例化时同时生成const &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);console.log(proxy.foo); // interceptedconsole.log(target.foo); // barrevoke();console.log(proxy.foo); // TypeError 实用反射 API 以下部分仅作了解即可 反射 API 与对象 API 在使用反射 API 时，要记住：(1) 反射 API并不限于捕获处理程序；(2) 大多数反射 API 方法在 Object 类型上有对应的方法。通常， Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。 状态标记1234567891011121314151617// 初始代码const o = &#123;&#125;;try &#123; Object.defineProperty(o, &#x27;foo&#x27;, &#x27;bar&#x27;); console.log(&#x27;success&#x27;);&#125; catch(e) &#123;\tconsole.log(&#x27;failure&#x27;);&#125;// 在定义新属性时如果发生问题， Reflect.defineProperty() 会返回 false ，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：// 重构后的代码const o = &#123;&#125;;if(Reflect.defineProperty(o, &#x27;foo&#x27;, &#123;value: &#x27;bar&#x27;&#125;)) &#123;\tconsole.log(&#x27;success&#x27;);&#125; else &#123;\tconsole.log(&#x27;failure&#x27;);&#125; 以下反射方法都会提供状态标记： Reflect.defineProperty() Reflect.preventExtensions() Reflect.setPrototypeOf() Reflect.set() Reflect.deleteProperty() 用一等函数替代操作符 以下反射方法提供只有通过操作符才能完成的操作。 Reflect.get() ：可以替代对象属性访问操作符。 Reflect.set() ：可以替代 &#x3D; 赋值操作符。 Reflect.has() ：可以替代 in 操作符或 with() 。 Reflect.deleteProperty() ：可以替代 delete 操作符。 Reflect.construct() ：可以替代 new 操作符。 安全地应用函数1234567//在通过 apply 方法调用函数时，被调用的函数可能也定义了自己的 apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法，比如：Function.prototype.apply.call(myFunc, thisVal, argumentList);// 这种可怕的代码完全可以使用 Reflect.apply 来避免：Reflect.apply(myFunc, thisVal, argumentsList); 代理另一个代理 代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网，这里不做代码演示了 代理模式 使用代理可以在代码中实现一些有用的编程模式。 跟踪属性访问123456789101112131415const user = &#123;\tname: &#x27;Jake&#x27;&#125;;const proxy = new Proxy(user, &#123; get(target, property, receiver) &#123; console.log(`Getting $&#123;property&#125;`); return Reflect.get(...arguments); &#125;, set(target, property, value, receiver) &#123; console.log(`Setting $&#123;property&#125;=$&#123;value&#125;`); return Reflect.set(...arguments); &#125;&#125;);proxy.name; // Getting nameproxy.age = 27; // Setting age=27 隐藏属性123456789101112131415161718192021222324252627282930const hiddenProperties = [&#x27;foo&#x27;, &#x27;bar&#x27;];const targetObject = &#123; foo: 1, bar: 2, baz: 3&#125;;const proxy = new Proxy(targetObject, &#123; get(target, property) &#123; if (hiddenProperties.includes(property)) &#123; return undefined; &#125; else &#123; return Reflect.get(...arguments); &#125;&#125;, has(target, property) &#123; if (hiddenProperties.includes(property)) &#123; return false; &#125; else &#123; return Reflect.has(...arguments); &#125;&#125;&#125;);// get()console.log(proxy.foo); // undefinedconsole.log(proxy.bar); // undefinedconsole.log(proxy.baz); // 3// has()console.log(&#x27;foo&#x27; in proxy); // falseconsole.log(&#x27;bar&#x27; in proxy); // falseconsole.log(&#x27;baz&#x27; in proxy); // true 属性验证12345678910111213141516const target = &#123; onlyNumbersGoHere: 0&#125;;const proxy = new Proxy(target, &#123; set(target, property, value) &#123; if (typeof value !== &#x27;number&#x27;) &#123; return false; &#125; else &#123; return Reflect.set(...arguments); &#125;&#125;&#125;);proxy.onlyNumbersGoHere = 1;console.log(proxy.onlyNumbersGoHere); // 1proxy.onlyNumbersGoHere = &#x27;2&#x27;;console.log(proxy.onlyNumbersGoHere); // 1 其它 还有包括但不限于函数与构造函数参数验证、数据绑定与可观察对象、事件派发（例如在set时触发emit）","tags":["JavaScript"],"categories":["前端学习"]},{"title":"fastdfs搭建分布式文件服务器","path":"/2021/03/21/fastdfs搭建分布式文件服务器/","content":"在Ubuntu中安装docker 我的ubuntu版本Linux ubuntu 4.4.0-186-generic 更新ubuntu的apt源索引 1sudo apt-get update 安装包允许apt通过HTTPS使用仓库 12345sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 添加Docker官方GPG key 1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 设置Docker稳定版仓库 1234sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 添加仓库后，更新apt源索引 1sudo apt-get update 安装最新版Docker CE（社区版） 1sudo apt-get install docker-ce 检查Docker CE是否安装正确 1sudo docker run hello-world docker的启动与停止安装完成Docker后，默认已经启动了docker服务，但后面可能有启停的需求 12345678# 启动dockersudo service docker start# 停止dockersudo service docker stop# 重启dockersudo service docker restart docker镜像操作普及查看已拉取镜像1docker images 拉取镜像1docker pull 镜像名 删除镜像12docker rmi 镜像id //镜像id通过docker images获取，一般前两位就够了例如id为a1b2c3 docker rmi a1就可以删除该镜像 docker容器操作普及创建容器12docker run [option] 镜像名 [向启动容器中传入的命令] 常用可选参数说明： -i 表示以“交互模式”运行容器 -t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。 –name 为创建的容器命名 -v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。 -d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不 会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。 -p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射 -e 为容器设置环境变量 –network&#x3D;host 表示将主机的网络环境映射到容器中，容器的网络与主机相同 进入容器1docker exec -it storage /bin/bash //storage为容器名 退出容器按住Ctrl再依次按下P Q两个字母键即可退出容器 使用Docker安装FastDFS获取镜像1docker pull delron/fastdfs 使用docker镜像构建tracker容器（跟踪服务器，起到调度的作用）123docker run -dti --network=host --name tracker -v /var/fdfs/tracker:/var/fdfs -v /etc/localtime:/etc/localtime delron/fastdfs tracker// 现在可以通过docker ps看下容器是否启动了 使用docker镜像构建storage容器（存储服务器，提供容量和备份服务）这里注意要替换一下中文‘本机ip地址’，本机ip不要使用localhost 1docker run -dti --network=host --name storage -e TRACKER_SERVER=本机ip地址:22122 -v /var/fdfs/storage:/var/fdfs -v /etc/localtime:/etc/localtime delron/fastdfs storage 进入storage容器 更改&#x2F;etc&#x2F;fdfs目录下的storage.conf123456789#进入容器docker exec -it storage bash #进入目录cd /etc/fdfs/ #编辑文件vi storage.conf 找到http.server_port&#x3D;8888 这里我直接使用默认的8888 **在storage容器中继续操作，修改nginx: ** 12345cd /usr/local/nginx/confvi nginx.conf# 找到http.server.listen 修改为上一步的8888 或者你改的端口，跟上面对应上就行 如果修改了则需要重启容器，使用默认的就不需要重启123456789# 重启有两种方式# 第一种docker stop storagedocker start storage# 第二种docker restart storage# 如果重启后无法启动的会，可能是报下面错误了，手动创建 vi /var/fdfs/logs/storaged.log 文件即可。报错：tail: cannot open &#x27;/var/fdfs/logs/storaged.log&#x27; for reading: No such file or directory 测试进入storage容器，进入&#x2F;var&#x2F;fdfs目录 123456789docker exec -it storage bashcd /var/fdfsecho hello 这是一个测试用例&gt;a.txt/usr/bin/fdfs_upload_file /etc/fdfs/client.conf a.txt# 如果返回的是一串以group1开头的路径，就成功了 在浏览器中访问已经上传的文件http://ip:8888/group1/xxxxxxxxxxxx.txt 开启端口我们在项目中远程连接，需要端口可访问，所以会用到以下命令 12345678# 查看防火墙状态sudo ufw status# 开启防火墙sudo ufw enable# 开放端口 8888就是要开发的端口，仅作示例sudo ufw allow 8888","tags":["FastFDS"],"categories":["环境搭建"]},{"title":"理解js中的call,apply,bind","path":"/2021/03/21/理解js中的call,apply,bind/","content":"前言自己学习this以及类似这种手写函数的时候，来来回回看了很多资料，但是都讲的比较笼统，也有可能是不太匹配我的理解模式，所以我以自己的方式表达出来，这篇文章适用于对js中的this有基本了解的同学，希望能帮助到需要的人。 Tips: 文章中的实现都比较粗糙，没有做边界处理。例子我都自己运行过了。 call实现call允许为不同的对象分配和调用属于一个对象的函数&#x2F;方法。也就是我们说的改变函数this指向。 思路整理 调用方式为&#96;fn.myCall(context)，所以我们需要直接在函数原型对象上定义 context有可能为null或者undefined，所以默认赋值为window 由于是fn.myCall，所以myCall内部的this就是fn本身,context就是我们this最后的目标对象 让我fn变成context对象的内部函数也就是context.fn &#x3D; fn 返回context.fn的结果 小结：让方法变成对象的内部方法，再通过该对象调用目标方法，达到让函数的this指向目标对象的目的。 简单实现 12345678910111213141516171819202122232425Function.prototype.myCall = function(context) &#123; // 为context兜底 context = context || window; // 将context的fn属性赋值为 调用mycall的函数 context.fn = this; // 整理参数 let args = [...arguments].slice(1); // 调用上面的参数执行context.fn return context.fn(...args);&#125;// 试一下let foo = &#123; name: &#x27;foo&#x27;&#125;, bar = &#123;\tname: &#x27;bar&#x27;, getName() &#123; return this.name; &#125;&#125;console.log(bar.getName.myCall(foo)); // foo apply实现有了上面实现call的思路，apply同理，只是要注意apply第二个参数是一个数组 12345678910111213Function.prototype.myApply = function(context) &#123; context = context || window; context.fn = this; let args = [...arguments].slice(1); //与上面不一样的是这里不用展开args数组 let res = context.fn(args); // 相比上面的call实现，我们多了一步delete delete context.fn; return res;&#125;// 由于跟上面的实现原理一样，这里不做演示 bind实现bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 和call, apply不同，bind返回的是一个函数，但是思路还是改变方法内部的this指向，需要注意的地方是bind调用时传参，返回的函数再调用时有可能再次传参，所以我们将所有的参数保留。 123456789101112131415161718192021222324252627Function.prototype.myBind = function(context) &#123; context = context || window; // 调用方式为fn.myBind, 所以这个__self就是函数本身，我们的目的就是使___self变成context的内部方法，再通过context去调用该方法。 let __self = this, outArgs = Array.from(arguments).slice(1); // 第一次传参 return function() &#123; //这里的arguments是第二次传参 return __self.apply(context, outArgs.concat([...arguments])) &#125;&#125;// 试一下let foo = &#123; name: &#x27;foo&#x27;&#125;, bar = &#123;\tname: &#x27;bar&#x27;, getName() &#123; return this.name; &#125;&#125;let test = bar.getName.myBind(foo);console.log(test()) // foo// 这里没有演示传参的效果，有兴趣的自己可以试下 End！","tags":["JavaScript"],"categories":["前端学习"]},{"title":"hover在移动端的问题","path":"/2021/01/24/hover在移动端的问题/","content":"例如下面这样一段代码 1234@media (any-hover: hover) &#123; box-shadow: 0 0 0 50vmax rgba(0, 0, 0, .5) background: transparent&#125; 在pc端是正常的，鼠标悬浮会有阴影扩散但是，在移动端点击之后，阴影不消失，需要再次点一下空白地方才能让阴影消失，因为移动端没有hover事件解决方案any-hover是用来适配支持hover事件的设备，使用如下代码代替hover 123@media (any-hover: hover)&#123;\t/* 在这写hover样式 */&#125;","tags":["CSS","前端适配"],"categories":["前端学习"]},{"path":"/friend/index.html","content":"特别感谢酷呵呵"},{"path":"/custom/css/ZYDark.css","content":"#ZYDark:root { --site-bg: #1c1e21; --card: #373d43; --block: #26292c; --block-border: #383d42; --block-hover: #2f3337; --text-p0: #fff; --text-p1: #ccc; --text-p2: #b3b3b3; --text-p3: #858585; --text-p4: #707070; --text-meta: #4d4d4d; --text-code: #ff6333; } @media screen and (max-width: 667px) { #ZYDark:root { --site-bg: #000; } } #ZYDark:root { --blur-bg: rgba(0,0,0,0.5); } #ZYDark .float-panel { --blur-bg: rgba(0,0,0,0.4); } #ZYDark .tag-plugin.tag { --theme: #ff6333; --theme-bg1: #3d1e14; --theme-bg2: #2f2522; --theme-border: #5c2d1f; --text-p0: #ffc4b3; --text-p1: #dfae9f; --text-p2: #f1997e; } #ZYDark .tag-plugin[color='red'] { --theme: #f44336; --theme-bg1: #3d1714; --theme-bg2: #2f2322; --theme-border: #5c231f; --text-p0: #ffb8b3; --text-p1: #dfa49f; --text-p2: #f1867e; } #ZYDark .tag-plugin[color='orange'] { --theme: #fa6400; --theme-bg1: #3d2514; --theme-bg2: #2f2722; --theme-border: #5c371f; --text-p0: #ffd1b3; --text-p1: #dfb99f; --text-p2: #f1ac7e; } #ZYDark .tag-plugin[color='yellow'] { --theme: #ffbd2b; --theme-bg1: #3d3014; --theme-bg2: #2f2b22; --theme-border: #5c491f; --text-p0: #ffe7b3; --text-p1: #dfcb9f; --text-p2: #f1cd7e; } #ZYDark .tag-plugin[color='green'] { --theme: #3dc550; --theme-bg1: #143d1a; --theme-bg2: #222f24; --theme-border: #1f5c27; --text-p0: #b3ffbd; --text-p1: #9fdfa8; --text-p2: #7ef18e; } #ZYDark .tag-plugin[color='cyan'] { --theme: #1bcdfc; --theme-bg1: #14353d; --theme-bg2: #222d2f; --theme-border: #1f4f5c; --text-p0: #b3efff; --text-p1: #9fd2df; --text-p2: #7ed9f1; } #ZYDark .tag-plugin[color='blue'] { --theme: #2196f3; --theme-bg1: #142b3d; --theme-bg2: #222a2f; --theme-border: #1f415c; --text-p0: #b3ddff; --text-p1: #9fc3df; --text-p2: #7ebef1; } #ZYDark .tag-plugin[color='purple'] { --theme: #9c27b0; --theme-bg1: #37143d; --theme-bg2: #2d222f; --theme-border: #531f5c; --text-p0: #f4b3ff; --text-p1: #d69fdf; --text-p2: #e07ef1; } #ZYDark .tag-plugin[color='light'] { --theme-border: #fff; --theme-bg1: #e0e0e0; --theme-bg2: #fff; --text-p0: #000; --text-p1: #111; --text-p2: #1f1f1f; --text-p3: #555; --text-code: #fff; } #ZYDark .tag-plugin[color='dark'] { --theme-border: #000; --theme-bg1: #1f1f1f; --theme-bg2: #111; --text-p0: #fff; --text-p1: #fff; --text-p2: #e0e0e0; --text-p3: #ddd; --text-code: #fff; } #ZYDark .tag-plugin[color='warning'], #ZYDark .tag-plugin[color='light'] { --text-p0: #000; --text-p1: #111; --text-p2: #1f1f1f; --text-p3: #555; --text-code: #fff; } #ZYDark .social-wrap a.social:hover { box-shadow: none; } /* waline评论样式 */ #ZYDark .wl-count{ padding: .375em; font-weight: bold; font-size: 1.25em; color: #fff; } #ZYDark .cmt-body.waline{ --waline-white: #000; --waline-light-grey: #666; --waline-dark-grey: #999; /* 布局颜色 */ --waline-color: #fff; --waline-bgcolor: var(--block); --waline-bgcolor-light: #272727; --waline-border-color: #333; --waline-disable-bgcolor: #444; --waline-disable-color: #272727; /* 特殊颜色 */ --waline-bq-color: #272727; /* 其他颜色 */ --waline-info-bgcolor: #272727; --waline-info-color: #666; }"},{"title":"Docker","path":"/wiki/notes/docker.html","content":"容器内部修改字符集食用场景：进入容器修改配置文件时，发现配置文件乱码 容器内乱码问题1234567891011121314// 进入容器docker exec -it &lt;container_id&gt; /bin/bash// 查看字符集 输出的全部keyvalue全部是带 POSIX 字眼的locale// 查看容器支持的字符集locale -a// 容器中临时使用，修改一次，退出失效，适用于临时调试export LANG=&quot;en_US.UTF-8&quot;// 永久设置需在Dockerfile中设置环境字符集环境变量 Dockerfile是用来构建docker镜像的，构建之前卸载文件中即可ENV LANG=&quot;en_US.UTF-8&quot; docker部署vue+expresshttps://blog.csdn.net/noscallion/article/details/121404664https://blog.csdn.net/noscallion/article/details/121404664 docker安装mysqlhttps://my.oschina.net/lumingbao/blog/3161797https://my.oschina.net/lumingbao/blog/3161797 设置容器自启动场景：针对已经在运行中的容器，更改restart属性 1docker update --restart=always &lt;containerName&gt; 查看容器日志1docker logs &lt;container name/id&gt;"},{"path":"/custom/js/ZYDark.js","content":"/** * 监听系统主题 * @type {MediaQueryList} */ var OSTheme = window.matchMedia('(prefers-color-scheme: dark)'); OSTheme.addListener(e => { if (window.localStorage.getItem('ZYI_Theme_Mode') === 'Moss') { ThemeChange('Moss'); } }) /** * 修改博客主题 * @param theme 亮为light,暗为dark,自动为auto * @constructor */ const ThemeChange = (theme) => { if (theme === 'light' || (theme === 'Moss' && !OSTheme.matches)) { document.querySelector(\"html\").id = \"ZYLight\"; document.querySelector(\"#start > aside > footer > div > a:nth-child(6)\").style.filter= 'grayscale(0%)'; document.querySelector(\"#start > aside > footer > div > a:nth-child(5)\").style.filter= 'grayscale(100%)'; } else { document.querySelector(\"html\").id = \"ZYDark\"; document.querySelector(\"#start > aside > footer > div > a:nth-child(5)\").style.filter= 'grayscale(0%)'; document.querySelector(\"#start > aside > footer > div > a:nth-child(6)\").style.filter= 'grayscale(100%)'; } if (theme==='Moss'){document.querySelector(\"#start > aside > footer > div > a:nth-child(7)\").style.filter= 'grayscale(0%)';} else {document.querySelector(\"#start > aside > footer > div > a:nth-child(7)\").style.filter= 'grayscale(100%)';} window.localStorage.setItem('ZYI_Theme_Mode', theme); } /** * 初始化博客主题 */ switch (window.localStorage.getItem('ZYI_Theme_Mode')) { case 'light': ThemeChange('light'); break; case 'dark': ThemeChange('dark'); break; default: ThemeChange('Moss'); } /** * 切换主题模式 */ document.querySelector(\"#start > aside > footer > div > a:nth-child(5)\").onclick = () => { ThemeChange('dark'); } document.querySelector(\"#start > aside > footer > div > a:nth-child(6)\").onclick = () => { ThemeChange('light'); } document.querySelector(\"#start > aside > footer > div > a:nth-child(7)\").onclick = () => { ThemeChange('Moss'); }"},{"title":"Hexo","path":"/wiki/notes/hexo.html","content":"站点美化记录页面居中注释第6行样式 themes\\stellar\\source\\css\\_layout\\main.styl123456789101112131415.l_main position: relative padding-bottom: &quot;calc(1 * %s)&quot; % var(--gap-l) @media screen and (min-width: 1400px) margin-left: &quot;calc(2 * %s)&quot; % var(--gap-l) /* margin-right: &quot;calc(2 * %s + %s / 2)&quot; % (var(--gap-l) var(--width-left)) */ @media screen and (min-width: $device-mobile-max) padding-top: &quot;calc(2 * %s)&quot; % var(--gap-l) @media screen and (max-width: $device-mobile-max) padding-top: 1rem header margin: 2rem 1rem 1rem .logo-wrap margin: 0 site网站卡片增加评分 修改类名和增加评分标签 注意是修改一行增加一行 themes/stellar/scripts/tags/lib/sites.js123// 33行, 也有可能是附近var cell = &#x27;&lt;div class=&quot;site-card d-relative&quot;&gt;&#x27; cell += item.rank ? &#x27;&lt;span class=&quot;d-absolute d-rank&quot;&gt;&#x27; + (parseInt(item.rank || 0).toFixed(1) || &#x27;暂无评分&#x27;) + &#x27;&lt;/span&gt;&#x27; : &#x27;&#x27; 新增的d-xxx的类名,代表我个人自定义的类名,下面我说一下如何引入 themes/stellar/source/css/在文件夹下新建_duck.styl文件, 这里duck是跟我博客相关的名字,方便区分,你可以自定义,随便啥名 themes/stellar/source/css/_duck.styl123456789101112131415161718.d-relative position: relative.d-absolute position: absolute.d-rank left: 4px top: 4px display: inline-block padding: 2px 4px font-size: 12px border-radius: 4px color: #fff z-index: 888 background: linear-gradient(#ffcc80, #cd7100) height: 12px line-height: 12px 在同层级目录下有个main.styl文件,5行附近应该是@import &#39;_custom&#39;,在他下面引入你上一步自定义的文件, 最后应该是: themes/stellar/source/css/main.styl123// 自定义参数@import &#x27;_custom&#x27;@import &#x27;_duck&#x27; 在source/_data/links.yml下配置的时候增加rank字段 举个栗子123456- title: 苍兰诀 url: https://www.iqiyi.com/v_ik3832z0go.html?vfm=m_103_txsp screenshot: http://forumupload.ru/uploads/001b/d7/0b/2/620123.webp avatar: http://forumupload.ru/uploads/001b/d7/0b/2/620123.webp description: 喜剧动漫，挺搞笑的 rank: 4 这个时候你应该能看到卡片上有评分了,不过鼠标悬浮在卡片上时,评分文字不跟随卡片一起浮动 增加浮动,在指定文件最后追加就行 themes/stellar/source/css/_layout/tag-plugins/sites.styl123456.site-card &gt;.d-rank trans2: box-shadow transform &amp;:hover &amp;&gt;.d-rank transform: translateY(-2px) 如果想根据自己的评分排序, 修改50行左右,增加一个sort函数就行 themes/stellar/scripts/tags/lib/sites.js1234items.forEach((item, i) =&gt; &#123;items.sort((a, b) =&gt; &#123; return b.rank - a.rank &#125;).forEach((item, i) =&gt; &#123; el += cell(item)&#125;) 这样就ok了 代码块展开收起思路: 当页面加载完毕(源代码中有个DOM fully loaded and parsed不知道你们注意到没有), 操作dom 在页面加载完毕的地方添加函数并调用 themes/stellar/layout/_partial/plugins/comments/waline/script.ejs123456789101112131415161718192021// 新增functionfunction fold_code() &#123; document.querySelectorAll(&#x27;figure&#x27;).forEach((block) =&gt; &#123; if (block.offsetHeight &gt; 300) &#123; block.classList.add(&#x27;d-collapsed&#x27;); block.insertAdjacentHTML(&#x27;beforeend&#x27;, `&lt;span class=&quot;d-expand-button&quot;&gt; &lt;svg t=&quot;1679580431116&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;8709&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M540.5696 556.81024a81.8176 81.8176 0 0 1-53.0432-19.47648l-225.4848-191.52896a81.92 81.92 0 1 1 106.0864-124.86656l172.4416 146.47296 172.4416-146.47296a81.92 81.92 0 0 1 106.0864 124.86656l-225.4848 191.52896a81.7152 81.7152 0 0 1-53.0432 19.47648z m53.06368 246.23104l225.44384-191.52896a81.92 81.92 0 1 0-106.0864-124.84608l-172.40064 146.47296-172.48256-146.47296a81.92 81.92 0 1 0-106.04544 124.86656l225.52576 191.52896a81.7152 81.7152 0 0 0 53.00224 19.47648c18.88256 0 37.76512-6.49216 53.0432-19.49696z&quot; p-id=&quot;8710&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;/span&gt;`); &#125; &#125;); document.querySelectorAll(&#x27;.d-expand-button&#x27;).forEach((button) =&gt; &#123; button.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; e.target.closest(&#x27;figure&#x27;).classList.toggle(&#x27;d-collapsed&#x27;) e.target.closest(&#x27;span&#x27;).classList.toggle(&#x27;d-rotating&#x27;) &#125;); &#125;); &#125; // 追加调用 console.log(&#x27;DOM fully loaded and parsed&#x27;); fold_code(); 在之前提到过的自定义样式文件步骤二中追加样式 themes/stellar/source/css/_duck.styl1234567891011121314151617181920212223242526272829303132333435363738394041/* 代码块折叠 */.d-collapsed max-height: 300px overflow-y: hidden !important position: relative !important.d-collapsed::after content: &quot;&quot; position: absolute bottom: 0 left: 0 right: 0 height: 50px background: linear-gradient(to bottom, rgba(255,255,255,0), #0000006b).d-expand-button animation: breath 2s ease-in-out infinite; color: #fff position: absolute bottom: 0 left: 50% transform: translateX(-50%) cursor: pointer z-index: 888 transition: all .3s; padding: 2px 24px @media (any-hover: hover) box-shadow: 0 0 0 50vmax rgba(0, 0, 0, .5) background: transparent@keyframes breath 0% color: #fff 50% color: #979797 100% color: #fff.d-rotating svg transform: rotate(180deg) ok了"},{"title":"Mysql","path":"/wiki/notes/mysql.html","content":"刷新权限1FLUSH PRIVILEGES;"},{"title":"追番","path":"/wiki/share/anime.html","content":"周三一念永恒https://www.aliyundrive.com/s/oczwr2gQ2cZ/folder/62d76582ce7509fb1427499c8a3a4df845b849f8吞噬星空https://www.aliyundrive.com/s/SgxXCANRAmS/folder/61e0f078c18037957f72402a9a38472d5495392e 周四神印王座https://www.aliyundrive.com/s/VLLJSAiFyFq/folder/626aaa58e4a22fd37b7846c5a2ca22ceb9430a62画江湖之不良人6https://www.aliyundrive.com/s/H3CFrpHY8mC/folder/622c44e10a840cdfdbf94c79ba01e588169ea459 周六神澜奇域无双珠https://www.aliyundrive.com/s/h173DaRSwT6/folder/62db6b1dc631b3a3c4bd4c11b7c6535a61700ec4 周天斗破苍穹-年番https://www.aliyundrive.com/s/xdnSuo7hMDz/folder/6290646eb4d4092d22704bfda5f19de447c3db68 推荐 已经根据个人观感评分排序, 仅个人观点勿喷 5.0代表真的很好看,本人强推4.0代表制作很好,但是你不一定喜欢看3.0代表一般般 5.0斗破苍穹推荐观看顺序：第一季（另外一个公司制作的，质量不太行，推荐缘起）/缘起 第二季1-2 特别篇1 第二季3-8 沙之澜歌 第二季9-12 第三季 第四季 三年之约 年番(更新中)5.0凡人修仙传小说改编，制作精良，不拖沓，并且制作组很愿意听取意见，针对观众提出的要求，有专门的重制版5.0不良人一天是不良人，一辈子都是不良人！4.0苍兰诀喜剧动漫，挺搞笑的4.0神澜奇域无双珠两位天才少年意外获得上古无双珠，相互嫌弃却成为伙伴4.0少年歌行这个很有意思，这一步是最先出的，但是故事线是最晚的，作者一直往回写。观看顺序：少年歌行-少年白马醉春风-君有云3.0两不疑皇帝皇后身体互换，两人从对方的工作生活逐渐相互理解最后修成圆满3.0绝代双骄动漫版的小鱼儿花无缺，3.0灵笼末世题材吧，挺好的，但是不推荐，更新太tmd慢了，感觉像是没有下文了，又一堆人在那吹，还整什么灵学家，我只能说没必要3.0永生能看，只能说能看"},{"title":"npm","path":"/wiki/notes/npm.html","content":"npm常见后缀含义npm -Dnpm -D就是npm --save-dev的简写会把moudule_name包安装到node_modules目录中会在package.json的devDependencies属性下添加moudule_name之后运行npm i命令时，会自动安装moudule_name到node_modules目录中之后运行npm i –production或者注明NODE_ENV变量值为production时，不会自动安装moudule_name到node_modules目录中 npm -Snpm -S就是npm --save的简写会把moudule_name包安装到node_modules目录中会在package.json的dependencies属性下添加moudule_name之后运行npm i命令时，会自动安装moudule_name到node_modules目录中之后运行npm i –production或者注明NODE_ENV变量值为production时，会自动安装msbuild到node_modules目录中,即是在线上环境运行时会将包安装 npm -g安装模块到全局，不会在项目node_modules目录中保存模块包。不会将模块依赖写入devDependencies或dependencies 节点。运行 npm i 初始化项目时不会下载模块。 npm设置全局路径本人强迫症，只要有软件要占用我的c盘空间，我就不同意虽然最后c盘还是红了。 12npm config set prefix &quot;E:/xxxx&quot;npm config set cache &quot;E:/xxx&quot; 关于 有些模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用-D的形式安装 有些模块是项目运行必备的，应该安装在 dependencies 节点下，所以我们应该使用-S的形式安装。总结为一句话：运行时需要用到的包使用–S，否则使用–D。"},{"title":"电视剧","path":"/wiki/share/tv.html","content":"TODO"},{"title":"电影","path":"/wiki/share/movie.html","content":"TODO"},{"title":"软件","path":"/wiki/share/software.html","content":"文件夹加密软件只有不到1M,全能往软件官网下载地址 使用方式将exe复制到需要加密的文件夹下双击运行 优点 能快速加密文件夹 缺点 加密之后完全解密（永久解除加密）文件多的话比较慢； 加密之后的文件夹能看到一把锁，点进去看不到内容 windows隐藏3D对象等~ emmm….这不是一个软件分享，但是懒得再单独为它创建一个分区了 场景说明 解决方法 windows+r后输入regedit,找到路径计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace 如图所示，可以直接删除，我这里直接加个自己能辨别的前缀，后面如果要恢复的话可以直接删除前缀 重启windows资源管理器 BandizipBandizip 一度是口碑极佳的最优秀好用的“免费压缩解压软件神器”，是无数人装机必备的工具之一。解压几十个G的文件竟然只要几分钟！软件界面清爽简洁无套路，完爆各种压缩软件。 蓝奏下载地址 视频转换HD Video Factory Pro这玩意是我用过转换视频格式最快的，而且还能增强画质！ 蓝奏下载 windows激活工具没啥好说的，**蓝奏下载** lx music免费听歌软件 蓝奏地址 utools别下载什么wox，真的不好用，这个可以快速打开应用，基本上桌面不用放东西，强迫症狂喜下载地址 idm下载器这个不用我介绍，我这个版本比较老，可以直接用，速度是一样的下载地址 绿色特别版 snipaste剪切板工具，精简，完全无广告，支持剪切内容固定到桌面，可以有效提高工作效率下载地址 火绒安全不多bb，也可以直接去官网下载，静默无广告，默默守护你下载地址 mem reduct3.2.2几kb的一个小工具，进程情况，内存管理，可视化，贼好用下载地址 jcpicker变色龙小工具，用来吸颜色的，设计或者前端用得着下载地址 ts转mp4自己写的一个小工具，要求windows安装了ffmpeg并且配置了其环境，只有几行代码，转化效率贼高，一般场景下都没问题下载地址 操作系统纯净操作系统下载地址"},{"title":"Centos","path":"/wiki/notes/linux/Centos.html","content":"防火墙的开关命令 设置开机启用防火墙1systemctl enable firewalld.service 设置开机禁用防火墙1systemctl disable firewalld.service 启动防火墙1systemctl start firewalld 关闭防火墙1systemctl stop firewalld 检查防火墙状态1systemctl status firewalld 使用firewall-cmd配置端口查看防火墙状态1firewall-cmd --state 重新加载配置1firewall-cmd --reload 查看开放的端口1firewall-cmd --list-ports 开启/关闭防火墙端口12345678910// –zone:作用域 –add-port=9200/tcp:添加端口，格式为：端口/通讯协议 –permanen:永久生效，否则重启失效firewall-cmd --zone=public --add-port=3333/tcp --permanent// 跟容器有关的下面这个命令可能管用firewall-cmd --zone=docker --add-port=3333/tcp --permanent// 添加新端口之后使用上方的reload命令重载生效//对应的关闭端口命令firewall-cmd --zone=public --remove-port=3333/tcp --permanent"},{"title":"Ubuntu","path":"/wiki/notes/linux/Ubuntu.html","content":"暂无"}]